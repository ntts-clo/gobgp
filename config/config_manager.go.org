// config_manager
package config

import (
	"fmt"
	"github.com/ant0ine/go-json-rest/rest"
	"log"
	"net/http"
)

func Config_for_Rest() {
	neighbors := Neighbors{
		Store: map[string]*Neighbor{},
	}

	handler := rest.ResourceHandler{
		EnableRelaxedContentType: true,
	}
	err := handler.SetRoutes(
		rest.RouteObjectMethod("GET", "/neighbors", &neighbors, "GetAllNeighbor"),
		rest.RouteObjectMethod("GET", "/neighbors/:Ip_address", &neighbors, "GetNeighbor"),
		rest.RouteObjectMethod("POST", "/neighbors", &neighbors, "PostNeighbor"),
		rest.RouteObjectMethod("PUT", "/neighbors/:Ip_address", &neighbors, "PutNeighbor"),
		rest.RouteObjectMethod("DELETE", "/neighbors", &neighbors, "DeleteAllNeighbor"),
		rest.RouteObjectMethod("DELETE", "/neighbors/:Ip_address", &neighbors, "DeleteNeighbor"),
	)
	if err != nil {
		log.Fatal(err)
	}
	log.Fatal(http.ListenAndServe(":"+REST_PORT, &handler))
}

func (n *Neighbors) GetAllNeighbor(w rest.ResponseWriter, r *rest.Request) {
	n.RLock()
	neighbors := make([]Neighbor, len(n.Store))
	i := 0
	for _, neighbor := range n.Store {
		neighbors[i] = *neighbor
		i++
	}
	n.RUnlock()
	w.WriteJson(&neighbors)
}

func (n *Neighbors) GetNeighbor(w rest.ResponseWriter, r *rest.Request) {
	Ip_address := r.PathParam("Ip_address")

	fmt.Println(n.Store)
	fmt.Println(Ip_address)

	n.RLock()
	var neighbor *Neighbor
	if n.Store[Ip_address] != nil {
		neighbor = &Neighbor{}
		*neighbor = *n.Store[Ip_address]
	}
	n.RUnlock()
	if neighbor == nil {
		rest.NotFound(w, r)
		return
	}
	w.WriteJson(neighbor)
}

func (n *Neighbors) PostNeighbor(w rest.ResponseWriter, r *rest.Request) {
	neighbor := Neighbor{}
	err := r.DecodeJsonPayload(&neighbor)
	if err != nil {
		rest.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	n.Lock()
	n.Store[neighbor.Ip_address] = &neighbor
	n.Unlock()
	w.WriteJson(&neighbor)
}
func (n *Neighbors) PutNeighbor(w rest.ResponseWriter, r *rest.Request) {
	Ip_address := r.PathParam("Ip_address")
	n.Lock()
	if n.Store[Ip_address] == nil {
		rest.NotFound(w, r)
		n.Unlock()
		return
	}
	neighbor := Neighbor{}
	err := r.DecodeJsonPayload(&neighbor)
	if err != nil {
		rest.Error(w, err.Error(), http.StatusInternalServerError)
		n.Unlock()
		return
	}
	neighbor.Ip_address = Ip_address
	n.Store[Ip_address] = &neighbor
	n.Unlock()
	w.WriteJson(&neighbor)
}
func (n *Neighbors) DeleteAllNeighbor(w rest.ResponseWriter, r *rest.Request) {
	n.Lock()
	n.Store = make(map[string]*Neighbor)
	n.Unlock()
	w.WriteHeader(http.StatusOK)
}

func (n *Neighbors) DeleteNeighbor(w rest.ResponseWriter, r *rest.Request) {
	Ip_address := r.PathParam("Ip_address")
	n.Lock()
	delete(n.Store, Ip_address)
	n.Unlock()
	w.WriteHeader(http.StatusOK)
}
